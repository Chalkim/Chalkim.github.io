---
title: 算法基础-贪心算法
date: 2021-01-22 21:45:52
mathjax: true
categories:
- 算法基础
- 贪心算法
tags:
- 算法
- 贪心算法
---

&emsp;&emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定**约束条件**。对于某一问题来说，满足约束条件的**可行解**可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即**目标函数**。使目标函数取得极值的解，即为**最优解**。

<!-- more -->

&emsp;&emsp;为了解决这类最优解问题，有线性规划、整数规划、非线性规划等等一系列算法。但对于其中的一些问题，可以用一种更直接的方法进行求解——贪心算法。

### 贪心算法

&emsp;&emsp;贪心算法是一种改进了的分级处理方法。首先根据问题选取一种度量方法；然后按照度量标准对n个输入排序，并按序一次输入一个量。如果该输入和当前已经构成的部分最优解加一起不能构成可行解，则不把该输入加入到解中。

```SPARKS
// 贪心算法的伪代码描述
procedure GREEDY(A, n)                           // A(1 : n) 包含n个输入
    solution <- NULL                             // 解向量初始化为空
    for i <- 1 to n do
        x <- SELECT(A)                           // 按照某种度量方法选择一个输入
        if FEASIBLE(solution, x)                 // 判断包含x的集是否为可行解
            then solution <- UNION(solution, x)  // 如可行，将x作为可行解的一部分
        endif
    repeat
    return(solution)
end GREEDY
```

&emsp;&emsp;要注意的是，许多量度标准取得的解并不是最优解，而是次优解。把目标函数作为量度标准的解也不一定是问题的最优解。实际上，选出最优量度标准不是是一件容易的事。

### 背包问题

&emsp;&emsp;设想这样一个场景：有一个最大承重`$M$`的背包，对于每种物品`$i$`的重量为`$W_i$`。假定当物品`$i$`的一部分`$x_i$`装入背包中可以获得`$p_i x_i$`的效益（`$0 \leq x_i \leq 1, p_i > 0$`）。求采用何种策略才能使得效益最大化？

&emsp;&emsp;以上问题可以用数学语言描述如下：

- 目标函数（取极大值）
$$
\sum\limits_{1 \leq i \leq n} p_i x_i
$$
- 约束条件
$$
\sum\limits_{1 \leq i \leq n} w_i x_i \leq M
$$
$$
0 \leq x_i \leq 1 , p_i > 0, 1 \leq i \leq n
$$

&emsp;&emsp;自然我们会希望背包装的东西在占用重量少的情况下又尽可能地能产生更大的效益。因此，我们可以把`$p_i / w_i$`作为量度标准。经过测试，采用这种量度标准的贪心算法可以获得最优解。将物体按`$p_i / w_i$`的递减次序排序，则过程 GREEDY-KNAPSACK 就得出一个最优解。如果不考虑排序的时间，则算法的需要的时间为O(n)。

```SPARKS
procedure GREEDY-KNAPSACK(P, W, M, X, n)
    // P(1:n)和W(1:n)分别含有按P(i)/W(i) >= P(i+1)/W(i+1)排序的n件物品的效益值和
    // 重量。M是背包的容量大小，X(1:n)是解向量。
    real P(1:n), W(1:n), X(1:n), M, cu;
    integer i, n;
    X <- 0     // 将解向量初始化为0
    cu <- M    // cu是背包剩余容量
    for i <- 1 to n do
        if W(i) > cu then exit endif
        X(i) <- 1
        cu <- cu - W(i)
    repeat
    if i <= n then X(i) <- cu/W(i)
    endif
end GREEDY-KNAPSACK
```

&emsp;&emsp;由此可见，贪心算法的核心在于量度标准的选取。

### 如何证明？

&emsp;&emsp;以上我们提到的关于背包问题的一种策略的解是最优解。我们该如何证明这一点呢？

&emsp;&emsp;有一个基本的想法是，把贪心算法的解与任一已知最优解作比较。如果这两个解不同，则按照解向量依次对`$x_i$`做替换。如果贪心解是最优解，那么在分量置换后的解也应当是个最优解，在背包问题中即总效应不变。重复执行这种替换，直到二者完全相同，就证明了贪心算法的解是最优解。

> 设X=(1:n)是上述策略产生的贪心解。若所有的`$x_i$`都为1，则显然该解为最优解。
> 
> 考虑不全为1的情况，由算法可知，存在一个j为`$x_j \neq 1$`的最小下标。若X不是一个最优解，则必然存在一个最优解Y使`$\sum\limits_{1\leq i\leq n}p_iy_i>\sum\limits_{1\leq i\leq n}p_ix_i$`。
>
> 设k是`$y_k \neq x_k$`的最小下标。从`$k < j, k = j, k > j$`三个方面展开讨论。
> 
> 1）若`$k < j$`，则`$x_k = 1$`。由于`$y_k < x_k$`，从而`$y_k < x_k$`。
>
> 2）若`$k = j$`，由于`$\sum w_j x_i = M$`，且对`$1 \leq i < j$`，有`$x_i = y_i = 1$`，而对`$j < i \leq n$`，有`$x_i = 0$`。若`$y_k > x_k$`，则`$\sum w_j y_i > M$`，与题设矛盾。故`$y_k < x_k$`。
>
> 3）若`$k > j$`，显然这是不可能的。
>
> 由此我们得到了`$y_k < x_k$`的结论。
>
> 现在假设我们把`$y_k$`增加到`$x_k$`，则需要从`$(y_{k+1}, y_{k+2},...,y_n)$`中减去同样多的量。使总量仍然为M。这就导致了一个新解Z。且有`$\sum\limits_{k<i\leq n} w_i(y_i - z_i) = w_k(z_k -y_k)$`。
>
> $$
> \begin{align}
> \sum\limits_{1\leq i \leq n}p_iz_i &= \sum\limits_{1\leq i\leq n}p_iy_i+(z_k-y_k)w_kp_k/w_k - \sum\limits_{k<i\leq n}(y_i-z_i)w_ip_i/w_i\\
> &\geq \sum\limits_{1\leq i\leq n}p_iy_i+[(z_k-y_k)w_k-\sum\limits_{k<i\leq n}(y_i-z_i)w_i]p_i/w_k\\
> &= \sum\limits_{1\leq i\leq n}p_iy_i
> \end{align}
> $$
> 若`$\sum p_iz_i>\sum p_iy_i$`，则Y不可能是最优解。若取等，`$Z=X$`，则`$X$`为最优解；若`$Z\neq X$`，则需重复以上讨论，或者证明Y不是最优解，或者把Y转换成X，从而证明X也是最优解。
