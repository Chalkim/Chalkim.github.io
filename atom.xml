<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chalkim&#39;s Blog</title>
  
  
  <link href="http://chalkim.ga/atom.xml" rel="self"/>
  
  <link href="http://chalkim.ga/"/>
  <updated>2021-02-15T15:19:40.521Z</updated>
  <id>http://chalkim.ga/</id>
  
  <author>
    <name>Chalkim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库基础-多值依赖与4NF</title>
    <link href="http://chalkim.ga/2021/02/04/shu-ju-ku-ji-chu-duo-zhi-yi-lai-yu-4nf/"/>
    <id>http://chalkim.ga/2021/02/04/shu-ju-ku-ji-chu-duo-zhi-yi-lai-yu-4nf/</id>
    <published>2021-02-04T22:57:26.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BCNF并非完美的范式，满足BCNF的关系模式依然有改进的空间。于此相关的就是多值依赖与更进一步的范式：4NF。</p><a id="more"></a><p>&emsp;&emsp;假设学校里开设的每门课程都由多名教师讲授，使用相同的一套参考书。每个教师可以教授多门课程，每本参考书也可以供多门课程使用。有如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 课程     | 教师       | 参考书                           |</span><br><span class="line">|----------|------------|----------------------------------|</span><br><span class="line">| 物理     | 李勇、王军 | 普通物理学、光学原理、物理习题集 |</span><br><span class="line">| 数学     | 李勇、张平 | 数学分析、微分方程、高等代数     |</span><br><span class="line">| 计算数学 | 张平、周峰 | 数学分析...                      |</span><br><span class="line">| ...      | ...        | ...                              |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将其规范化后有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">| 课程 | 教师 | 参考书     |</span><br><span class="line">|------|------|------------|</span><br><span class="line">| 物理 | 李勇 | 普通物理学 |</span><br><span class="line">| 物理 | 李勇 | 光学原理   |</span><br><span class="line">| 物理 | 李勇 | 物理习题集 |</span><br><span class="line">| 物理 | 王军 | 普通物理学 |</span><br><span class="line">| 物理 | 王军 | 光学原理   |</span><br><span class="line">| 物理 | 王军 | 物理习题集 |</span><br><span class="line">| 数学 | 李勇 | 数学分析   |</span><br><span class="line">| 数学 | 李勇 | 微分方程   |</span><br><span class="line">| 数学 | 李勇 | 高等代数   |</span><br><span class="line">| 数学 | 张平 | 数学分析   |</span><br><span class="line">| 数学 | 张平 | 微分方程   |</span><br><span class="line">| 数学 | 张平 | 高等代数   |</span><br><span class="line">| ...  | ...  | ...        |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于该关系模型的码是（课程，教师，参考书），是全码（All-Key），因此满足BCNF的要求。尽管如此依然存在着种种缺陷。</p><p>&emsp;&emsp;如果我们要对某门课程增加（更改、删除）一本参考书，或者是增加一个教师。则必须对多个元组进行操作，这样的操作很麻烦，数据的冗余也很明显。而BCNF已经是考虑函数依赖规范化程度的极限了，实际上这种情况与另外一种数据依赖方式多值依赖相关。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><blockquote><p>&emsp;&emsp;设R(U)是属性集U上的一个关系模式。X、Y、Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)的值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p></blockquote><p>&emsp;&emsp;抽象的定义就介绍到这里。以我们上面的例子为例，对于一个（物理，普通物理学）有一组教师（李勇、王军），而教师只由课程物理决定，与普通物理学无关。因此课程-&gt;-&gt;教师，即教师多值依赖于课程。</p><p>&emsp;&emsp;相似的有对于一个（物理，李勇），都有一组参考书（普通物理学、光学原理、物理习题集）与之对应。而参考书与教师是不是李勇无关，只与课程物理有关系。因此课程-&gt;-&gt;参考书，即参考书多值依赖于课程。</p><div class="note warning">            <h4 id="注意与函数依赖的区别！"><a href="#注意与函数依赖的区别！" class="headerlink" title="注意与函数依赖的区别！"></a>注意与函数依赖的区别！</h4><ol><li><p>函数依赖是特殊的多值依赖。</p></li><li><p>函数依赖X-&gt;Y只与X和Y相关，而多值依赖则还与U中的其他属性Z相关。因此当属性集变大时，函数依赖依然存在，但多值依赖则可能消失。</p></li><li><p>若函数依赖X-&gt;Y成立，则对于Y的任意一个子集Y‘，都有X-&gt;Y’成立。而对于多值依赖则没有这样类似的结论。</p></li></ol>          </div><h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><p>&emsp;&emsp;关系模式R&lt;U,F&gt;满足1NF，若对于R的每一个<strong>非平凡多值依赖</strong>X-&gt;-&gt;Y，X都含有码，则称R&lt;U,F&gt;满足4NF。</p><blockquote><p>非平凡多值依赖就是Z不为空集的情况。实际上由于4NF定义X含有码，因此有X-&gt;Y。4NF所允许的非平凡多值依赖就是函数依赖。</p></blockquote><p><img src="/2021/02/04/shu-ju-ku-ji-chu-duo-zhi-yi-lai-yu-4nf/4NF_1.svg" alt="4NF_1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;BCNF并非完美的范式，满足BCNF的关系模式依然有改进的空间。于此相关的就是多值依赖与更进一步的范式：4NF。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="范式" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="范式" scheme="http://chalkim.ga/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础-函数依赖与范式</title>
    <link href="http://chalkim.ga/2021/02/02/shu-ju-ku-ji-chu-fan-shi/"/>
    <id>http://chalkim.ga/2021/02/02/shu-ju-ku-ji-chu-fan-shi/</id>
    <published>2021-02-02T17:20:08.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;为了设计出一个好的关系型数据库模式，需要按照规范化（Normalization）方法对关系模式进行优化。满足不同程度要求的规范化被称作范式。下面将在函数依赖的范畴内，依次讨论1NF、2NF、3NF与BCNF。</p><a id="more"></a><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>&emsp;&emsp;1NF要求每一个分量必须是不可分的数据项。简而言之就是不能表中有表：</p><blockquote><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/1NF_1.png" alt="1NF_1"></p></blockquote><p>&emsp;&emsp;这是最基本的规范化，满足1NF的数据库模式依然可能存在插入异常、删除异常、冗余过大的问题。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>&emsp;&emsp;在满足1NF的基础上，每一个非主属性（Non-prime attribute）「即不出现在任何码中的属性」<strong>完全函数依赖</strong>于码（Key），则满足2NF。</p><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><h5 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h5><p>&emsp;&emsp;对于函数依赖X-&gt;Y，有任意X的真子集X’，满足Y不函数依赖于X’，则X-&gt;Y称为完全函数依赖。</p><h5 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h5><p>&emsp;&emsp;不是完全函数依赖的就是部分函数依赖。</p><p>&emsp;&emsp;对于不满足2NF的关系模式，解决问题的方法是用投影将原关系模式为两个关系模式。</p><blockquote><p>&emsp;&emsp;学生-地址-选课关系(学号，系所，地址，课程号，成绩)</p><p>&emsp;&emsp;在这个关系中（学号，课程号）是码。学号唯一确定院系与住址，院系唯一确定住址，学号与课程号唯一确定成绩。在这个关系中存在非主属性部分函数依赖于码，如住址部分依赖于（学号，课程号）。</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/2NF_1.svg" alt="2NF_1"></p><p>&emsp;&emsp;分解为两个关系</p><p>&emsp;&emsp;学生-课程关系（学号，课程号，成绩），码是（学号，课程号）。</p><p>&emsp;&emsp;学生-地址关系（学号，系所，住址），码是学号。</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/2NF_2.svg" alt="2NF_2"></p><p>&emsp;&emsp;这样每一个关系内都不存在部分函数依赖于码的情况了。</p></blockquote><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>&emsp;&emsp;消除非主属性对码的传递函数依赖。即每一个非主属性既不部分依赖于码也不传递依赖于码。</p><p>&emsp;&emsp;X-&gt;Y, Y-&gt;Z, 但X不函数依赖于Y（如果有Y-&gt;X，则是X直接决定Z），则Z传递依赖于X。存在这样关系的关系模式则不符合3NF。</p><p>&emsp;&emsp;解决的方法是将关系模式分解。</p><blockquote><p>&emsp;&emsp;刚才分解后的学生-地址关系中包含非主属性对码的传递依赖。</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/3NF_1.svg" alt="3NF_1"></p><p>&emsp;&emsp;可以看到学号-&gt;系所（但没有系所-&gt;学号），系所-&gt;地址。因此按照传递依赖的定义，地址传递依赖于学号。（虽然有学号-&gt;地址但是和我们这里的传递依赖没关系）</p><p>&emsp;&emsp;由于地址是非主属性，因此这是不满足3NF的定义的，需要进行分解。</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/3NF_2.svg" alt="3NF_2"></p><p>&emsp;&emsp;学号-系所关系（学号，系所），码是学号。</p><p>&emsp;&emsp;系所-地址关系（系所，地址），码是系所。</p><p>&emsp;&emsp;分解后不存在非主属性对码的传递依赖，满足3NF</p></blockquote><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>&emsp;&emsp;要使一个关系模式满足BCNF，则至少要满足以下条件：</p><blockquote><ol><li><p>所有非主属性对每一个码都是完全函数依赖。</p></li><li><p>所有主属性对每一个不包含它的码也是完全函数依赖。</p></li><li><p>没有任何属性完全函数依赖于非码的任何一组属性。</p></li></ol></blockquote><p>&emsp;&emsp;其实比3NF就多了主属性对码也不能有部分或传递函数依赖。</p><blockquote><p>&emsp;&emsp;比分说下面这个例子</p><p>&emsp;&emsp;学生-教师-课程关系（学生，教师，课程）中，教师只教一门课，每门课对应多名教师。学生选定某门课就对应一名教师。</p><p>&emsp;&emsp;码有两个（学生，课程），（学生，教师）</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/BCNF_1.svg" alt="BCNF_1"></p><p>&emsp;&emsp;这里所有属性都是主属性，不存在非主属性，因此满足3NF。</p><p>&emsp;&emsp;但对于课程来说，教师直接决定课程。因此主属性课程对（学生，教师）部分函数依赖，不符合BCNF定义。</p><p>&emsp;&emsp;优化的方法依然是分解。</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/BCNF_2.svg" alt="BCNF_2"></p><p>&emsp;&emsp;学生-教师关系（学生，教师），码是学生。</p><p>&emsp;&emsp;教师-课程关系（教师，课程），码是教师。</p><p>&emsp;&emsp;这样就满足BCNF了。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>规范化过程：</p><p><img src="/2021/02/02/shu-ju-ku-ji-chu-fan-shi/summary_1.svg" alt="summary_1"></p><p>&emsp;&emsp;至此，关于函数依赖相关的范式介绍完毕，但尽管是满足BCNF的关系模式依然有所不足，这时就需要要求4NF进行约束。「关于4NF的讨论见<a href="/TODO">数据库基础-多值依赖与4NF</a>」</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;为了设计出一个好的关系型数据库模式，需要按照规范化（Normalization）方法对关系模式进行优化。满足不同程度要求的规范化被称作范式。下面将在函数依赖的范畴内，依次讨论1NF、2NF、3NF与BCNF。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="范式" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="范式" scheme="http://chalkim.ga/tags/%E8%8C%83%E5%BC%8F/"/>
    
    <category term="函数依赖" scheme="http://chalkim.ga/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础-关系代数与SQL</title>
    <link href="http://chalkim.ga/2021/01/31/shu-ju-ku-ji-chu-guan-xi-dai-shu-yu-sql/"/>
    <id>http://chalkim.ga/2021/01/31/shu-ju-ku-ji-chu-guan-xi-dai-shu-yu-sql/</id>
    <published>2021-01-31T18:22:33.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;关系型数据库使用SQL语言进行操作，而关系代数是表达查询的一种抽象的查询语言。在了解SQL之前，有必要学习关系代数的表达方式。</p><a id="more"></a><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ul><li><p>并：属于R或属于S的元组的集合，表示为<script type="math/tex">R\cup S</script>。</p></li><li><p>差：属于R但不属于S的元组的集合，表示为<script type="math/tex">R-S</script>。</p></li><li><p>交：既属于R又属于S的元组的集合，表示为<script type="math/tex">R\cap S</script>。</p></li><li><p>广义笛卡尔积：两个分别为n目和m目的关系R和S的笛卡尔积是一个(n+m)列的元组的集合。表示为<script type="math/tex">R\times S</script>。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R:                S:</span><br><span class="line">| A  | B  | C  |  | A  | B  |</span><br><span class="line">|----|----|----|  |----|----|</span><br><span class="line">| a1 | b1 | c1 |  | a2 | b1 |</span><br><span class="line">| a2 | b2 | c2 |  | a3 | b2 |</span><br><span class="line">| a3 | b3 | b4 |</span><br><span class="line"></span><br><span class="line">R×S:</span><br><span class="line">| A  | B  | C  | A  | B  |</span><br><span class="line">|----|----|----|----|----|</span><br><span class="line">| a1 | b1 | c1 | a2 | b1 |</span><br><span class="line">| a1 | b1 | c1 | a3 | b2 |</span><br><span class="line">| a2 | b2 | c2 | a2 | b1 |</span><br><span class="line">| a2 | b2 | c2 | a3 | b2 |</span><br><span class="line">| a3 | b3 | b4 | a2 | b1 |</span><br><span class="line">| a3 | b3 | b4 | a3 | b2 |</span><br></pre></td></tr></table></figure><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4></li></ul><ol><li>选择（Selection）</li></ol><p>&emsp;&emsp;表示在关系R中选择满足给定条件的元组，表示为<script type="math/tex">\sigma_{\text{F}}(R)</script>，其中F表示选择条件。</p><p>&emsp;&emsp;eg:<script type="math/tex">\sigma_{\text{age<20}}(Student)</script></p><ol><li>投影（Projection）</li></ol><p>&emsp;&emsp;指从关系R中选择出某些属性列组成新的关系。由于取消了部分列，可能出现重复元组，应取消相同的行。表示为<script type="math/tex">\pi_\text{A}(R)</script>。</p><p>&emsp;&emsp;eg:<script type="math/tex">\pi_\text{dept}(Student)</script></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student            Projection:</span><br><span class="line">| Sname | Sdept |  | Sdept |</span><br><span class="line">|-------|-------|  |-------|</span><br><span class="line">| aaa   | CS    |  | CS    |</span><br><span class="line">| bbb   | IS    |  | IS    |</span><br><span class="line">| ccc   | IS    |</span><br></pre></td></tr></table></figure><ol><li>连接（Join）</li></ol><p>&emsp;&emsp;连接指从笛卡尔积中选择属性间满足某条件的元组。表示为<script type="math/tex">R{\bowtie\over{A\theta B}}S</script>。<script type="math/tex">\theta</script>是比较运算符。</p><p>&emsp;&emsp;<script type="math/tex">\theta</script>为<script type="math/tex">=</script>时，该连接运算称为<strong>等值连接</strong>。</p><p>&emsp;&emsp;自然连接是一种特殊的等值连接，要求比较的分量是相同的属性组，并去掉重复的属性列。记作<script type="math/tex">R\bowtie S</script></p><ol><li>除（Division）</li></ol><p>&emsp;&emsp;给定关系R(X, Y)和S(Y, Z)，其中X, Y, Z为属性组。表示为<script type="math/tex">R\div S</script>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R            S            R÷S</span><br><span class="line">| X  | Y  |  | Y  | Z  |  | X  |</span><br><span class="line">|----|----|  |----|----|  |----|</span><br><span class="line">| x1 | y1 |  | y2 | z1 |  | x2 |</span><br><span class="line">| x2 | y1 |  | y2 | z2 |</span><br><span class="line">| x2 | y2 |  | y3 | z1 |</span><br><span class="line">| x2 | y3 |</span><br><span class="line">| x3 | y2 |</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出除操作就是将S对Y属性投影，然后取出R中包含该投影集合的X，消去重复项目得到的集合。</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>&emsp;&emsp;以上都是关系运算的数学表达，为了转化成数据库系统能够识别的表达，引入了SQL语言。下面将使用SQL语言对各类关系操作进行表示。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 单表查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 查询所有属性列 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 查询计算值 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, <span class="number">2021</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 消除重复行 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno           <span class="comment">-- 默认为ALL，即保留重复行</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 满足特定条件 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两句等价 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> Sage <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 范围 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 集合 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="string">&#x27;IS&#x27;</span>, <span class="string">&#x27;MA&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单表查询 - 字符匹配 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex    <span class="comment">-- % 代表任意长度字符串</span></span><br><span class="line"><span class="keyword">FROM</span> Student               <span class="comment">-- _ 代表任意单字符</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;    <span class="comment">-- 刘xx，刘x，刘xxxxxx</span></span><br><span class="line">                           <span class="comment">-- +----------------+</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname               <span class="comment">-- |    \%    \_    |   转义</span></span><br><span class="line"><span class="keyword">FROM</span> Student               <span class="comment">-- +----------------+</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;欧阳__&#x27;</span>; <span class="comment">-- 欧阳xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span>;       <span class="comment">-- IS 不能换成 =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多重条件 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> (Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>) <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排序 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;       <span class="comment">-- DESC 降序， ASC 升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 集函数 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>);           <span class="comment">-- 统计元组个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(Attr);        <span class="comment">-- 统计某一列值的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Attr);          <span class="comment">-- 计算某一列值总和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Attr);          <span class="comment">-- 计算某一列平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Attr);          <span class="comment">-- 求某一列最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Attr);          <span class="comment">-- 求某一列最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对结果分组 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Cno, <span class="built_in">COUNT</span>(Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;              <span class="comment">-- 按照Cno进行分组，具有相同Cno的元组分为一组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HAVING */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 连接查询 */</span></span><br><span class="line"><span class="comment">/* 等值连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自然连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自身连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno(<span class="operator">*</span>);    <span class="comment">-- 右外连接， *表示允许空值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复合条件连接 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span></span><br><span class="line">      SC.Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">      SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 嵌套查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname            <span class="comment">-- 父查询</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">    <span class="keyword">SELECT</span> Sno          <span class="comment">-- 子查询</span></span><br><span class="line">    <span class="keyword">FROM</span> SC</span><br><span class="line">    <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;      <span class="comment">-- 子查询不能使用ORDER BY</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> Sage</span><br><span class="line">                 <span class="keyword">FROM</span> Student</span><br><span class="line">                 <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">!=</span> <span class="string">&#x27;IS&#x27;</span>;          <span class="comment">-- 等价于Sage &lt; (SELECT MAX(Sage) ...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="built_in">MAX</span>(<span class="keyword">SELECT</span> Sage</span><br><span class="line">                 <span class="keyword">FROM</span> Student</span><br><span class="line">                 <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">!=</span> <span class="string">&#x27;IS&#x27;</span>;          <span class="comment">-- 等价于Sage &lt; (SELECT MIN(Sage) ...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>                      <span class="comment">-- 返回 TRUE 或 FALSE</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">/* 集合查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span>              <span class="comment">-- 合并两个查询的结果，自动消除重复项</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;=</span><span class="number">19</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;SELECT语句一般形式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [别名] [, <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [别名]]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [别名] [, <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [别名]]...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意的WHERE和HAVING的区别！</span></span><br><span class="line"><span class="comment">WHERE作用于表/视图，HAVING作用于组（GROUP）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;关系型数据库使用SQL语言进行操作，而关系代数是表达查询的一种抽象的查询语言。在了解SQL之前，有必要学习关系代数的表达方式。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库基础" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    <category term="SQL" scheme="http://chalkim.ga/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/SQL/"/>
    
    
    <category term="关系代数" scheme="http://chalkim.ga/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
    <category term="SQL" scheme="http://chalkim.ga/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>最优二叉搜索树算法</title>
    <link href="http://chalkim.ga/2021/01/29/zui-you-er-cha-sou-suo-shu-suan-fa/"/>
    <id>http://chalkim.ga/2021/01/29/zui-you-er-cha-sou-suo-shu-suan-fa/</id>
    <published>2021-01-29T15:46:12.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最优二叉搜索树算法是一种<a href="/2021/01/26/suan-fa-ji-chu-dong-tai-gui-hua/">动态规划算法</a>。该算法解决的问题是：在给定结点出现频率的前提下，如何组织一颗二叉搜索树，使所有搜索操作访问的结点数最少？这也是一个最优解问题。</p><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>&emsp;&emsp;给定一个n个不同关键字的已排序的序列K，用该序列构建一颗二叉搜索树。对于每个关键字<script type="math/tex">k_i</script>，都有一个概率<script type="math/tex">p_i</script>表示其搜索频率。有些要搜索的值可能不在K中，应次还有n+1个伪关键字<script type="math/tex">d_0,d_1,\cdots,d_n</script>表示不在K中的值。$d_0$表示所有小于<script type="math/tex">k_1</script>的值，<script type="math/tex">d_n</script>表示所有大于<script type="math/tex">k_n</script>的值。对于每一个<script type="math/tex">d_i</script>,也有一个概率<script type="math/tex">q_i</script>表示其搜索频率。每次查找要么成功（找到某个关键字），要么失败（找到某个伪关键字）。</p><script type="math/tex; mode=display">\sum\limits_{i=1}^nP_i+\sum\limits_{i=0}^nq_i=1</script><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>&emsp;&emsp;一颗n=5的最优二叉树（期望搜索代价为2.75）：</p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>$p_i$</td><td></td><td>0.15</td><td>0.10</td><td>0.05</td><td>0.10</td><td>0.20</td></tr><tr><td>$q_i$</td><td>0.05</td><td>0.10</td><td>0.05</td><td>0.05</td><td>0.05</td><td>0.10</td></tr></tbody></table></div><pre class="mermaid">graph TB  k2((k2))-->k1((k1))  k2-->k5((k5))  k1-->d0((d0))  k1-->d1((d1))  k5-->k4((k4))  k5-->d5((d5))  k4-->k3((k3))  k3-->d2((d2))  k3-->d3((d3))  k4-->d4((d4))</pre><script type="math/tex; mode=display">E[T中搜索代价]=1+\sum\limits_{i=1}^ndepth_T(k_i)\cdot p_i+\sum\limits_{i=1}^ndepth_T(d_i)\cdot q_i</script><h3 id="刻画最优子结构"><a href="#刻画最优子结构" class="headerlink" title="刻画最优子结构"></a>刻画最优子结构</h3><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>&emsp;&emsp;如果一颗最优二叉搜索树T有一颗包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的子树T‘，则其必然是包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>和伪关键字<script type="math/tex">d_{i-1},\cdots ,d_{j}</script>的最优解。如果存在子树T’’，其期望搜索代价比T’低。则用T’’替换T’，则与T最优的假设矛盾。</p><p>&emsp;&emsp;因此我们可以利用最优子结构的性质，检查所有可能的根结点<script type="math/tex">k_i</script>，对其求解包含<script type="math/tex">k_i,\cdots ,k_{r-1}</script>及包含<script type="math/tex">k_{r+1},\cdots ,k_j</script>的最优二叉搜索树，即可找到原问题最优解。</p><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>&emsp;&emsp;子问题域：求解包含关键字<script type="math/tex">k_i,\cdots,k_j</script>的最优二叉搜索树。<script type="math/tex">e[i,j]</script>为包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的最优二叉搜索树的期望代价。最终求出<script type="math/tex">e[1,n]</script>。</p><p>&emsp;&emsp;子树概率之和为</p><script type="math/tex; mode=display">w[i,j]=\sum\limits_{l=i}^jp_l+\sum\limits_{l=i-1}^jq_l</script><p>&emsp;&emsp;<script type="math/tex">j=i-1</script>时，子树只包含伪关键字<script type="math/tex">d_{i-1}</script>。</p><p>&emsp;&emsp;<script type="math/tex">i\leq j</script>时，子树<script type="math/tex">e[i,j]=p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))</script>，因为<script type="math/tex">w(i,j)=w(i,r-1)+p_r+w(r+1,j)</script>，可以得到如下递归公式：</p><script type="math/tex; mode=display">e[i,j]=\begin{cases}q_{i-1}&\text{若j=i-1}\\\min\limits_{i\leq r\leq j}\{e[i,r-1]+e[r+1,j]+w(i,j)\}&\text{若n>1}\end{cases}</script><h4 id="改为迭代算法"><a href="#改为迭代算法" class="headerlink" title="改为迭代算法"></a>改为迭代算法</h4><p>&emsp;&emsp;上述递归实现相对低效，用迭代算法进行改进。用表<script type="math/tex">e[1..n+1, 0..n]</script>保存<script type="math/tex">e[i,j]</script>。另外使用<script type="math/tex">root[i,j]</script>记录包含关键字<script type="math/tex">k_i,\cdots ,k_j</script>的子树的根。为了避免每次计算<script type="math/tex">e[i,j]</script>时都重新计算<script type="math/tex">w(i,j)</script>，使用表<script type="math/tex">w[1..n, 0..n]</script>保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OPTIMAL-SET(p,q,n)</span><br><span class="line">&#x2F;&#x2F; p为关键字k_i的概率表，q为伪关键字d_i的概率表，n为问题规模</span><br><span class="line">    let e[1..n+1,0..n], w[1..n+1,0..n], and root[1..n, 1..n] be new tables</span><br><span class="line">&#x2F;&#x2F; 第一维上标为n+1是为了考虑只包含d[n+1]的情况</span><br><span class="line">&#x2F;&#x2F; 第二维下标为0是为了考虑只包含d[0]的情况</span><br><span class="line">    for i &#x3D; 1 to n+1</span><br><span class="line">        e[i,i-1] &#x3D; q[i-1]</span><br><span class="line">        w[i,i-1] &#x3D; q[i-1]                          &#x2F;&#x2F; 初始化</span><br><span class="line">    for l &#x3D; 1 to n                                 &#x2F;&#x2F; 子树宽度</span><br><span class="line">        for i &#x3D; 1 to n-l+1</span><br><span class="line">            j &#x3D; i+l-1                              &#x2F;&#x2F; 自底向上遍历所有可能的子树</span><br><span class="line">            e[i,j] &#x3D; inf                           &#x2F;&#x2F; 初始化</span><br><span class="line">            w[i,j] &#x3D; w[i, j-1] + p[j] + q[j]</span><br><span class="line">            for r &#x3D; i to j                         &#x2F;&#x2F; 选择根结点</span><br><span class="line">                t &#x3D; e[i,r-1] + e[r+1,j] + w[i,j]</span><br><span class="line">                if t &lt; e[i,j]                      &#x2F;&#x2F; 取最小值</span><br><span class="line">                    e[i,j]&#x3D;t</span><br><span class="line">                    root[i,j]&#x3D;r</span><br><span class="line">    return e and root</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行时间为<script type="math/tex">\theta (n^3)</script>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;最优二叉搜索树算法是一种&lt;a href=&quot;/2021/01/26/suan-fa-ji-chu-dong-tai-gui-hua/&quot;&gt;动态规划算法&lt;/a&gt;。该算法解决的问题是：在给定结点出现频率的前提下，如何组织一颗二叉搜索树，使所有搜索操作访问的结点数最少？这也是一个最优解问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="动态规划" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://chalkim.ga/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉搜索树" scheme="http://chalkim.ga/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-动态规划</title>
    <link href="http://chalkim.ga/2021/01/26/suan-fa-ji-chu-dong-tai-gui-hua/"/>
    <id>http://chalkim.ga/2021/01/26/suan-fa-ji-chu-dong-tai-gui-hua/</id>
    <published>2021-01-26T23:40:11.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;同<a href="/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/">贪心算法</a>一样，动态规划所要解决的问题通常也是最优解问题。在策略上，动态规划与<a href="/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/">分治法</a>相似，都是把复杂问题分解为数个子问题。不同的地方在于，分治法分解出的子问题均是独立的，即均需要进行单独的演算。而动态规划解决的是公共子问题，并将其保存以供重复利用，因此避免了大量不必要的计算工作。</p><a id="more"></a><p>&emsp;&emsp;一个动态规划算法的步骤大致有如下四步：</p><blockquote><ol><li>刻画一个最优解的结构特征。</li><li>递归地定义最优解的值。</li><li>计算最优解的值，通常采用自底向上的方法。</li><li>利用计算出的信息构造一个最优解。</li></ol></blockquote><h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>&emsp;&emsp;对于给定的一段长为n英寸的钢条和一个价格表<script type="math/tex">p_i</script>（样例如下）。</p><div class="table-container"><table><thead><tr><th>长度<script type="math/tex">i</script></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>价格<script type="math/tex">P_i</script></td><td>1</td><td>5</td><td>8</td><td>9</td><td>10</td><td>17</td><td>17</td><td>20</td><td>24</td><td>30</td></tr></tbody></table></div><p>&emsp;&emsp;假设切割所需的成本为0，如何切割钢条可以使收益<script type="math/tex">r_n</script>最大化？</p><p>&emsp;&emsp;应用动态规划的思想，我们将原问题分解为一系列子问题。</p><h4 id="最优解的结构特征"><a href="#最优解的结构特征" class="headerlink" title="最优解的结构特征"></a>最优解的结构特征</h4><p>&emsp;&emsp;对于一个钢条，我们总可以选择一个切割方案将钢条切成<script type="math/tex">k</script>段（<script type="math/tex">k=1</script>时表示不切割）如此一个最优解就应当是这种形式：</p><script type="math/tex; mode=display">n=i_1+i_2+\cdots+i_n</script><p>&emsp;&emsp;从而获取最大收益<script type="math/tex">r_n</script></p><script type="math/tex; mode=display">r_n=p_{i_1}+p_{i_2}+\cdots+p_{i_n}</script><p>&emsp;&emsp;考虑<script type="math/tex">n=1</script>的情况，只能选择不切割的方案，此时获取收益为1。考虑<script type="math/tex">n=2</script>的情况，可以选择不切割或切割为两个长度为1的钢条，取收益较大者即可。而对于更普遍的情况，实际上我们总能用如下表达式表示最大收益。</p><script type="math/tex; mode=display">r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},\cdots,r_{n-1}+r_1)\tag{1}</script><blockquote><p><del>这里应该可以省去一半的计算量</del></p></blockquote><p>&emsp;&emsp;可以看出我们为了获取更普遍的情况，实际上是用子问题的最优解组合出最优解。因此我们说钢条切割问题具有<strong>最优子结构性质</strong>。</p><div class="note warning">            <h5 id="注意与分治法的区别！"><a href="#注意与分治法的区别！" class="headerlink" title="注意与分治法的区别！"></a>注意与分治法的区别！</h5><p>&emsp;&emsp;分治法不要求问题具有最优子结构性质，例如归并排序时我们只需要能够利用两子序列归并即可。但对于每一个子问题均是独立存在的，是需要单独计算的。而对于不具有最优子结构性质的问题，我们几乎就能断言其不适用动态规划了。</p>          </div><h4 id="递归地定义最优解的值"><a href="#递归地定义最优解的值" class="headerlink" title="递归地定义最优解的值"></a>递归地定义最优解的值</h4><p>&emsp;&emsp;简化<script type="math/tex">(1)</script>可以得到<script type="math/tex">r_n=\max\limits_{1\leq i\leq n}(p_i+r_{n-i})</script>。因此我们可以得到如下伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为数组，即价格表；n为待处理钢条长度</span><br><span class="line">    if(n &#x3D;&#x3D; 0)                                 &#x2F;&#x2F; 长度为0没有收益</span><br><span class="line">        return 0</span><br><span class="line">    q &#x3D; -inf                                   &#x2F;&#x2F; 初始化</span><br><span class="line">    for i &#x3D; 1 to n</span><br><span class="line">        q &#x3D; max(q, p[i] + CUT-ROD(p,n - i))</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，这个算法确实可以计算出最优解。但由于其递归实现，其时间复杂度相当巨大。分析n=3的情况，可以得到如下递归树。</p><pre class="mermaid">graph TB    n11((3))    n21((2))    n22((1))    n23((0))    n31((1))    n32((0))    n33((0))    n41((0))    n11---n21    n11---n22    n11---n23    n21---n31    n21---n32    n22---n33    n31---n41</pre><p>&emsp;&emsp;由递归树可知，对n个输入，对应结点数目为<script type="math/tex">2^n</script>个。其中有很多部分是重复的子问题，如果我们能够将其保存并加以利用，那么就可以降低算法的复杂度了。</p><blockquote><script type="math/tex; mode=display">T(n) =\begin{cases}1&\text{若n=0}\\\sum\limits_{j=0}^{n-1}T(j)&{其他}\end{cases}</script><p>可以证明<script type="math/tex">T(n)=2^n</script>，为一指数函数。实际上到这一步，对于分治法来说已经足够了，但对于动态规划还远远不够。</p></blockquote><h4 id="计算最优解的值"><a href="#计算最优解的值" class="headerlink" title="计算最优解的值"></a>计算最优解的值</h4><p>&emsp;&emsp;由于递归版本的算法运行时间太长，实用性很低，因此有必要进行改进。改进的方法一般有两种，一是<strong>带备忘的自顶向下法</strong>，二是<strong>自底向上法</strong>。</p><h5 id="带备忘的自顶向下法"><a href="#带备忘的自顶向下法" class="headerlink" title="带备忘的自顶向下法"></a>带备忘的自顶向下法</h5><p>&emsp;&emsp;如字面意思，该版本的改进在于在递归过程中加入了对子问题最优解值的保存。在需要子问题的解的时候，程序首先检查是否保存了该解，从而省去了计算的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 带备忘的自顶向下法的伪代码描述</span><br><span class="line">MEMOIZED-CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为价格表，n为待处理钢条长度</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    for i &#x3D; 0 to n</span><br><span class="line">        r[i] &#x3D; -inf                                              &#x2F;&#x2F; 初始化备忘</span><br><span class="line">    return MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line"></span><br><span class="line">MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line">    if r[n] &gt;&#x3D; 0</span><br><span class="line">        return r[n]                                              &#x2F;&#x2F; 存在备忘直接取出</span><br><span class="line">    if n &#x3D;&#x3D; 0</span><br><span class="line">        q &#x3D; 0</span><br><span class="line">    else q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 0 to n</span><br><span class="line">            q &#x3D; max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i ,r))</span><br><span class="line">    r[n] &#x3D; q                                                     &#x2F;&#x2F; 保存备忘</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure><h5 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            q &#x3D; max(q, p[i] + r[j-i])</span><br><span class="line">        r[j]&#x3D;q</span><br><span class="line">    return r[n]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与自顶向下法比较，可以发现自底向上法最重要的地方三添加了第4行，以及将递归调用改为直接从r中取出。由于用取值代替了递归调用，算法自然不能像递归算法一样一层层继续下去，因此有必要添加自底向上的迭代方法。</p><p>&emsp;&emsp;容易得到该改进版本运行时间为<script type="math/tex">\theta(n^2)</script>，实际上MEMOIZED-CUT-ROD运行时间也是上式。</p><h4 id="利用计算出的信息构造一个最优解"><a href="#利用计算出的信息构造一个最优解" class="headerlink" title="利用计算出的信息构造一个最优解"></a>利用计算出的信息构造一个最优解</h4><p>&emsp;&emsp;到这一步我们已经计算得到了最大收益的值，但实际上对于钢条的切割方案并未提供最优解。这一步就是要保存每一段切割长度<script type="math/tex">s_j</script>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXTENDED-BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] and s[0..n] be new arrays                &#x2F;&#x2F; r是备忘，s是最优解</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            if q &lt; p[i] + r[j-i]</span><br><span class="line">                q &#x3D; p[i] + r[j-i]</span><br><span class="line">                s[j] &#x3D; i</span><br><span class="line">        r[j] &#x3D; q</span><br><span class="line">    return r and s</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;要应用动态规划解决问题，问题需要具备以下两个性质：<strong>最优子结构</strong>和<strong>子问题重叠</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;同&lt;a href=&quot;/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/&quot;&gt;贪心算法&lt;/a&gt;一样，动态规划所要解决的问题通常也是最优解问题。在策略上，动态规划与&lt;a href=&quot;/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/&quot;&gt;分治法&lt;/a&gt;相似，都是把复杂问题分解为数个子问题。不同的地方在于，分治法分解出的子问题均是独立的，即均需要进行单独的演算。而动态规划解决的是公共子问题，并将其保存以供重复利用，因此避免了大量不必要的计算工作。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="动态规划" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://chalkim.ga/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-分治法</title>
    <link href="http://chalkim.ga/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/"/>
    <id>http://chalkim.ga/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/</id>
    <published>2021-01-25T22:47:42.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;分治法是一种常见的算法设计思想。许多算法在结构上是递归的，这些算法采用的往往就是分治法。分治法的思想是将复杂问题分解为几个规模较小的但形式类似于原问题的子问题。递归地求解出子问题，再合并子问题的解，从而构建出原问题的解。</p><a id="more"></a><p>&emsp;&emsp;分治法在每层递归有三个步骤：</p><blockquote><ol><li>分解原问题为若干子问题；</li><li>解决子问题；</li><li>合并子问题的解，建立原问题的解。</li></ol></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&emsp;&emsp;其中一个典型的应用就是归并排序，上述三个步骤对应描述如下：</p><blockquote><ol><li>分解：将待排序的n个元素分解为两个包含n/2元素的子序列；</li><li>解决：使用归并排序递归地排序两个子序列；</li><li>合并：合并两个已排序的子序列。</li></ol></blockquote><p>&emsp;&emsp;由于算法是递归的，所以可以预见到递归的末端所需处理的子序列长度均为1。此时对于这些子序列不需我们进行任何多余工作即自然地满足排序的要求。</p><p>&emsp;&emsp;分解工作完成后，下一步操作就需要解决问题。解决问题的操作是调用了一个MERGE的辅助过程。该过程对两个已排好序的子序列进行合并，产生一个新的顺序序列。</p><p>&emsp;&emsp;对于MERGE具体的思想是：重复比较两个子序列的首个元素，取其中最小的元素，将其添加到新产生的顺序序列中。直到一个子序列的所有元素都被添加到新序列中，此时可以确保另外一个非空的子序列均比已经处理的元素要大。因此我们可以直接将其合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MERGE 伪代码描述</span><br><span class="line">MERGE(A, p, q, r)</span><br><span class="line">&#x2F;&#x2F; 其中A是一个数组。A[p, q]和A[q + 1, r]是已经排序的两个子序列。</span><br><span class="line">    n1 &#x3D; q - p + 1                       &#x2F;&#x2F; 序列1包含的元素数量</span><br><span class="line">    n2 &#x3D; r - q                           &#x2F;&#x2F; 序列2包含的元素数量</span><br><span class="line">    let L[1..n1+1] and R[1..n2+1] be new arrays</span><br><span class="line">    for i &#x3D; 1 to n1</span><br><span class="line">        L[i] &#x3D; A[p + i - 1]</span><br><span class="line">    for j &#x3D; 1 to n2</span><br><span class="line">        R[j] &#x3D; A[q + j]                  &#x2F;&#x2F; 复制</span><br><span class="line">    L[n1 + 1] &#x3D; inf                      &#x2F;&#x2F; 两个inf是标志算法可以停止的哨兵</span><br><span class="line">    R[n2 + 1] &#x3D; inf                      &#x2F;&#x2F; 这里是为了简化代码实现</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    j &#x3D; 1</span><br><span class="line">    for k &#x3D; p to r                       &#x2F;&#x2F; 假设j &#x3D; n2+1，则L[i]均比R[j]小</span><br><span class="line">        if L[i] &lt;&#x3D; R[j]                  &#x2F;&#x2F; 比较首元素大小</span><br><span class="line">            A[k] &#x3D; L[i]</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">        else                             &#x2F;&#x2F; 放置较小的那一个</span><br><span class="line">            A[k] &#x3D; R[j]</span><br><span class="line">            j &#x3D; j + 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们已经具备了完成该算法的所有条件了，让我们完成它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line">&#x2F;&#x2F; A[p, r]是一个数组，即待排序序列</span><br><span class="line">    if p &lt; r</span><br><span class="line">        q &#x3D; (p + r) &#x2F; 2                  &#x2F;&#x2F; 向下取整</span><br><span class="line">        MERGE-SORT(A, p, q)</span><br><span class="line">        MERGE-SORT(A, q+1, r)            &#x2F;&#x2F; 分割原序列为两个序列</span><br><span class="line">        MERGE(A, p, q, r)                &#x2F;&#x2F; 合并两个已排序的子序列</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;值得注意的是，当A只含1项时该过程的行为。A.length = 1时，有p = r，不满足判断条件，即该过程什么都不做。两个长度为1的子序列MERGE成为一个长为2的新序列…</p><p>&emsp;&emsp;以此类推，自底向上，由小序列不断合成为新序列，最终完成原序列的排序工作。至此我们终于完成了归并排序的算法设计。</p><pre class="mermaid">graph BT    12[2 5]    1[5]-->|归并|12    2[2]-->|归并|12    34[4 7]    3[4]-->|归并|34    4[7]-->|归并|34    1234[2 4 5 7]    12-->|归并|1234    34-->|归并|1234</pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>&emsp;&emsp;我们知道归并排序最坏情况下的运行时间为<script type="math/tex">\theta(nlgn)</script>，而插入排序则为<script type="math/tex">\theta(n^2)</script>。显然归并排序在输入足够大的最坏情况下要快于插入排序。为什么？</p><p>&emsp;&emsp;分析程序运行步骤我们可以得到以下结论：</p><blockquote><ol><li>分解：将原序列分解为两个子序列，耗费<script type="math/tex">\theta(1)</script>时间</li><li>解决：递归地解决两个规模为n/2的子问题，耗费<script type="math/tex">2T(n/2)</script>时间</li><li>合并：MERGE过程最多需要处理n个元素，因此耗费<script type="math/tex">\theta(n)</script>时间</li></ol></blockquote><p>&emsp;&emsp;因此我们获得了最坏情况下T(n)的递归式：</p><script type="math/tex; mode=display">T(n)=\begin{cases}\theta(1)&\text{若n=1}\\2T(n/2)+\theta(n)&\text{若n>1}\end{cases}</script><p>&emsp;&emsp;为求解该表达式，我们需要引入一个定理。</p><blockquote><p>&emsp;&emsp;要求解<script type="math/tex">T(n)=aT(n/b)+f(n)</script>的渐进界，其中<script type="math/tex">a\geq1,b>1</script>为常数，<script type="math/tex">f(n)</script>为一个函数。<br>则有以下三种情况：</p><ol><li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=O(n^{log_ba-\epsilon})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba})</script>。</li><li>若<script type="math/tex">f(n)=\theta(n^{log_ba})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba}lgn)</script>。</li><li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=\Omega(n^{log_ba+\epsilon})</script>，且对某个常数<script type="math/tex">c<1</script>和所有足够大的<script type="math/tex">n</script>有<script type="math/tex">af(n/b)\leq cf(n)</script>，则<script type="math/tex">T(n)=\theta(f(n))</script>。</li></ol></blockquote><p>&emsp;&emsp;对于归并排序算法，我们有<script type="math/tex">a=2,b=2,f(n)=\theta(n)</script>，则<script type="math/tex">n^{log_ba}=n^{log_22}=n</script>，两者大小相当，应用情况2。于是我们求得<script type="math/tex">T(n)=\theta(nlgn)</script>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;分治法是一种常见的算法设计思想。许多算法在结构上是递归的，这些算法采用的往往就是分治法。分治法的思想是将复杂问题分解为几个规模较小的但形式类似于原问题的子问题。递归地求解出子问题，再合并子问题的解，从而构建出原问题的解。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="分治法" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
    
    <category term="分治法" scheme="http://chalkim.ga/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-贪心算法</title>
    <link href="http://chalkim.ga/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/"/>
    <id>http://chalkim.ga/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/</id>
    <published>2021-01-22T21:45:52.000Z</published>
    <updated>2021-02-15T15:19:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定<strong>约束条件</strong>。对于某一问题来说，满足约束条件的<strong>可行解</strong>可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即<strong>目标函数</strong>。使目标函数取得极值的解，即为<strong>最优解</strong>。</p><a id="more"></a><p>&emsp;&emsp;为了解决这类最优解问题，有线性规划、整数规划、非线性规划等等一系列算法。但对于其中的一些问题，可以用一种更直接的方法进行求解——贪心算法。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>&emsp;&emsp;贪心算法是一种改进了的分级处理方法。首先根据问题选取一种度量方法；然后按照度量标准对n个输入排序，并按序一次输入一个量。如果该输入和当前已经构成的部分最优解加一起不能构成可行解，则不把该输入加入到解中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 贪心算法的伪代码描述</span><br><span class="line">procedure GREEDY(A, n)                           &#x2F;&#x2F; A(1 : n) 包含n个输入</span><br><span class="line">    solution &lt;- NULL                             &#x2F;&#x2F; 解向量初始化为空</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        x &lt;- SELECT(A)                           &#x2F;&#x2F; 按照某种度量方法选择一个输入</span><br><span class="line">        if FEASIBLE(solution, x)                 &#x2F;&#x2F; 判断包含x的集是否为可行解</span><br><span class="line">            then solution &lt;- UNION(solution, x)  &#x2F;&#x2F; 如可行，将x作为可行解的一部分</span><br><span class="line">        endif</span><br><span class="line">    repeat</span><br><span class="line">    return(solution)</span><br><span class="line">end GREEDY</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;要注意的是，许多量度标准取得的解并不是最优解，而是次优解。把目标函数作为量度标准的解也不一定是问题的最优解。实际上，选出最优量度标准不是是一件容易的事。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>&emsp;&emsp;设想这样一个场景：有一个最大承重<script type="math/tex">M</script>的背包，对于每种物品<script type="math/tex">i</script>的重量为<script type="math/tex">W_i</script>。假定当物品<script type="math/tex">i</script>的一部分<script type="math/tex">x_i</script>装入背包中可以获得<script type="math/tex">p_i x_i</script>的效益（<script type="math/tex">0 \leq x_i \leq 1, p_i > 0</script>）。求采用何种策略才能使得效益最大化？</p><p>&emsp;&emsp;以上问题可以用数学语言描述如下：</p><ul><li>目标函数（取极大值）<script type="math/tex; mode=display">\sum\limits_{1 \leq i \leq n} p_i x_i</script></li><li>约束条件<script type="math/tex; mode=display">\sum\limits_{1 \leq i \leq n} w_i x_i \leq M</script><script type="math/tex; mode=display">0 \leq x_i \leq 1 , p_i > 0, 1 \leq i \leq n</script></li></ul><p>&emsp;&emsp;自然我们会希望背包装的东西在占用重量少的情况下又尽可能地能产生更大的效益。因此，我们可以把<script type="math/tex">p_i / w_i</script>作为量度标准。经过测试，采用这种量度标准的贪心算法可以获得最优解。将物体按<script type="math/tex">p_i / w_i</script>的递减次序排序，则过程 GREEDY-KNAPSACK 就得出一个最优解。如果不考虑排序的时间，则算法的需要的时间为O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">procedure GREEDY-KNAPSACK(P, W, M, X, n)</span><br><span class="line">    &#x2F;&#x2F; P(1:n)和W(1:n)分别含有按P(i)&#x2F;W(i) &gt;&#x3D; P(i+1)&#x2F;W(i+1)排序的n件物品的效益值和</span><br><span class="line">    &#x2F;&#x2F; 重量。M是背包的容量大小，X(1:n)是解向量。</span><br><span class="line">    real P(1:n), W(1:n), X(1:n), M, cu;</span><br><span class="line">    integer i, n;</span><br><span class="line">    X &lt;- 0     &#x2F;&#x2F; 将解向量初始化为0</span><br><span class="line">    cu &lt;- M    &#x2F;&#x2F; cu是背包剩余容量</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        if W(i) &gt; cu then exit endif</span><br><span class="line">        X(i) &lt;- 1</span><br><span class="line">        cu &lt;- cu - W(i)</span><br><span class="line">    repeat</span><br><span class="line">    if i &lt;&#x3D; n then X(i) &lt;- cu&#x2F;W(i)</span><br><span class="line">    endif</span><br><span class="line">end GREEDY-KNAPSACK</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见，贪心算法的核心在于量度标准的选取。</p><h3 id="如何证明？"><a href="#如何证明？" class="headerlink" title="如何证明？"></a>如何证明？</h3><p>&emsp;&emsp;以上我们提到的关于背包问题的一种策略的解是最优解。我们该如何证明这一点呢？</p><p>&emsp;&emsp;有一个基本的想法是，把贪心算法的解与任一已知最优解作比较。如果这两个解不同，则按照解向量依次对<script type="math/tex">x_i</script>做替换。如果贪心解是最优解，那么在分量置换后的解也应当是个最优解，在背包问题中即总效应不变。重复执行这种替换，直到二者完全相同，就证明了贪心算法的解是最优解。</p><blockquote><p>设X=(1:n)是上述策略产生的贪心解。若所有的<script type="math/tex">x_i</script>都为1，则显然该解为最优解。</p><p>考虑不全为1的情况，由算法可知，存在一个j为<script type="math/tex">x_j \neq 1</script>的最小下标。若X不是一个最优解，则必然存在一个最优解Y使<script type="math/tex">\sum\limits_{1\leq i\leq n}p_iy_i>\sum\limits_{1\leq i\leq n}p_ix_i</script>。</p><p>设k是<script type="math/tex">y_k \neq x_k</script>的最小下标。从<script type="math/tex">k < j, k = j, k > j</script>三个方面展开讨论。</p><p>1）若<script type="math/tex">k < j</script>，则<script type="math/tex">x_k = 1</script>。由于<script type="math/tex">y_k < x_k</script>，从而<script type="math/tex">y_k < x_k</script>。</p><p>2）若<script type="math/tex">k = j</script>，由于<script type="math/tex">\sum w_j x_i = M</script>，且对<script type="math/tex">1 \leq i < j</script>，有<script type="math/tex">x_i = y_i = 1</script>，而对<script type="math/tex">j < i \leq n</script>，有<script type="math/tex">x_i = 0</script>。若<script type="math/tex">y_k > x_k</script>，则<script type="math/tex">\sum w_j y_i > M</script>，与题设矛盾。故<script type="math/tex">y_k < x_k</script>。</p><p>3）若<script type="math/tex">k > j</script>，显然这是不可能的。</p><p>由此我们得到了<script type="math/tex">y_k < x_k</script>的结论。</p><p>现在假设我们把<script type="math/tex">y_k</script>增加到<script type="math/tex">x_k</script>，则需要从<script type="math/tex">(y_{k+1}, y_{k+2},...,y_n)</script>中减去同样多的量。使总量仍然为M。这就导致了一个新解Z。且有<script type="math/tex">\sum\limits_{k<i\leq n} w_i(y_i - z_i) = w_k(z_k -y_k)</script>。</p><script type="math/tex; mode=display">\begin{align}\sum\limits_{1\leq i \leq n}p_iz_i &= \sum\limits_{1\leq i\leq n}p_iy_i+(z_k-y_k)w_kp_k/w_k - \sum\limits_{k<i\leq n}(y_i-z_i)w_ip_i/w_i\\&\geq \sum\limits_{1\leq i\leq n}p_iy_i+[(z_k-y_k)w_k-\sum\limits_{k<i\leq n}(y_i-z_i)w_i]p_i/w_k\\&= \sum\limits_{1\leq i\leq n}p_iy_i\end{align}</script><p>若<script type="math/tex">\sum p_iz_i>\sum p_iy_i</script>，则Y不可能是最优解。若取等，<script type="math/tex">Z=X</script>，则<script type="math/tex">X</script>为最优解；若<script type="math/tex">Z\neq X</script>，则需重复以上讨论，或者证明Y不是最优解，或者把Y转换成X，从而证明X也是最优解。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定&lt;strong&gt;约束条件&lt;/strong&gt;。对于某一问题来说，满足约束条件的&lt;strong&gt;可行解&lt;/strong&gt;可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即&lt;strong&gt;目标函数&lt;/strong&gt;。使目标函数取得极值的解，即为&lt;strong&gt;最优解&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法基础" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="贪心算法" scheme="http://chalkim.ga/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心算法" scheme="http://chalkim.ga/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
