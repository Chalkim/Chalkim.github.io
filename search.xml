<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法基础-分治法</title>
    <url>/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;分治法是一种常见的算法设计思想。许多算法在结构上是递归的，这些算法采用的往往就是分治法。分治法的思想是将复杂问题分解为几个规模较小的但形式类似于原问题的子问题。递归地求解出子问题，再合并子问题的解，从而构建出原问题的解。</p>
<p>&emsp;&emsp;分治法在每层递归有三个步骤：</p>
<blockquote>
<ol>
<li>分解原问题为若干子问题；</li>
<li>解决子问题；</li>
<li>合并子问题的解，建立原问题的解。</li>
</ol>
</blockquote>
<a id="more"></a>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&emsp;&emsp;其中一个典型的应用就是归并排序，上述三个步骤对应描述如下：</p>
<blockquote>
<ol>
<li>分解：将待排序的n个元素分解为两个包含n/2元素的子序列；</li>
<li>解决：使用归并排序递归地排序两个子序列；</li>
<li>合并：合并两个已排序的子序列。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;由于算法是递归的，所以可以预见到递归的末端所需处理的子序列长度均为1。此时对于这些子序列不需我们进行任何多余工作即自然地满足排序的要求。</p>
<p>&emsp;&emsp;分解工作完成后，下一步操作就需要解决问题。解决问题的操作是调用了一个MERGE的辅助过程。该过程对两个已排好序的子序列进行合并，产生一个新的顺序序列。</p>
<p>&emsp;&emsp;对于MERGE具体的思想是：重复比较两个子序列的首个元素，取其中最小的元素，将其添加到新产生的顺序序列中。直到一个子序列的所有元素都被添加到新序列中，此时可以确保另外一个非空的子序列均比已经处理的元素要大。因此我们可以直接将其合并。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; MERGE 伪代码描述</span><br><span class="line">MERGE(A, p, q, r)</span><br><span class="line">&#x2F;&#x2F; 其中A是一个数组。A[p, q]和A[q + 1, r]是已经排序的两个子序列。</span><br><span class="line">    n1 &#x3D; q - p + 1                       &#x2F;&#x2F; 序列1包含的元素数量</span><br><span class="line">    n2 &#x3D; r - q                           &#x2F;&#x2F; 序列2包含的元素数量</span><br><span class="line">    let L[1..n1+1] and R[1..n2+1] be new arrays</span><br><span class="line">    for i &#x3D; 1 to n1</span><br><span class="line">        L[i] &#x3D; A[p + i - 1]</span><br><span class="line">    for j &#x3D; 1 to n2</span><br><span class="line">        R[j] &#x3D; A[q + j]                  &#x2F;&#x2F; 复制</span><br><span class="line">    L[n1 + 1] &#x3D; inf                      &#x2F;&#x2F; 两个inf是标志算法可以停止的哨兵</span><br><span class="line">    R[n2 + 1] &#x3D; inf                      &#x2F;&#x2F; 这里是为了简化代码实现</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    j &#x3D; 1</span><br><span class="line">    for k &#x3D; p to r                       &#x2F;&#x2F; 假设j &#x3D; n2+1，则L[i]均比R[j]小</span><br><span class="line">        if L[i] &lt;&#x3D; R[j]                  &#x2F;&#x2F; 比较首元素大小</span><br><span class="line">            A[k] &#x3D; L[i]</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">        else                             &#x2F;&#x2F; 放置较小的那一个</span><br><span class="line">            A[k] &#x3D; R[j]</span><br><span class="line">            j &#x3D; j + 1</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在我们已经具备了完成该算法的所有条件了，让我们完成它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line">&#x2F;&#x2F; A[p, r]是一个数组，即待排序序列</span><br><span class="line">    if p &lt; r</span><br><span class="line">        q &#x3D; (p + r) &#x2F; 2                  &#x2F;&#x2F; 向下取整</span><br><span class="line">        MERGE-SORT(A, p, q)</span><br><span class="line">        MERGE-SORT(A, q+1, r)            &#x2F;&#x2F; 分割原序列为两个序列</span><br><span class="line">        MERGE(A, p, q, r)                &#x2F;&#x2F; 合并两个已排序的子序列</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;值得注意的是，当A只含1项时该过程的行为。A.length = 1时，有p = r，不满足判断条件，即该过程什么都不做。两个长度为1的子序列MERGE成为一个长为2的新序列…</p>
<p>&emsp;&emsp;以此类推，自底向上，由小序列不断合成为新序列，最终完成原序列的排序工作。至此我们终于完成了归并排序的算法设计。</p>
<pre class="mermaid">graph BT
    12[2 5]
    1[5]-->|归并|12
    2[2]-->|归并|12
    34[4 7]
    3[4]-->|归并|34
    4[7]-->|归并|34
    1234[2 4 5 7]
    12-->|归并|1234
    34-->|归并|1234</pre>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>&emsp;&emsp;我们知道归并排序最坏情况下的运行时间为<script type="math/tex">\theta(nlgn)</script>，而插入排序则为<script type="math/tex">\theta(n^2)</script>。显然归并排序在输入足够大的最坏情况下要快于插入排序。为什么？</p>
<p>&emsp;&emsp;分析程序运行步骤我们可以得到以下结论：</p>
<blockquote>
<ol>
<li>分解：将原序列分解为两个子序列，耗费<script type="math/tex">\theta(1)</script>时间</li>
<li>解决：递归地解决两个规模为n/2的子问题，耗费<script type="math/tex">2T(n/2)</script>时间</li>
<li>合并：MERGE过程最多需要处理n个元素，因此耗费<script type="math/tex">\theta(n)</script>时间</li>
</ol>
</blockquote>
<p>&emsp;&emsp;因此我们获得了最坏情况下T(n)的递归式：</p>
<script type="math/tex; mode=display">
T(n)=
\begin{cases}
\theta(1)&\text{若n=1}\\
2T(n/2)+\theta(n)&\text{若n>1}
\end{cases}</script><p>&emsp;&emsp;为求解该表达式，我们需要引入一个定理。</p>
<blockquote>
<p>&emsp;&emsp;要求解<script type="math/tex">T(n)=aT(n/b)+f(n)</script>的渐进界，其中<script type="math/tex">a\geq1,b>1</script>为常数，<script type="math/tex">f(n)</script>为一个函数。<br>则有以下三种情况：</p>
<ol>
<li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=O(n^{log_ba-\epsilon})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba})</script>。</li>
<li>若<script type="math/tex">f(n)=\theta(n^{log_ba})</script>，则<script type="math/tex">T(n)=\theta(n^{log_ba}lgn)</script>。</li>
<li>若对某个常数<script type="math/tex">\epsilon>0</script>有<script type="math/tex">f(n)=\Omega(n^{log_ba+\epsilon})</script>，且对某个常数<script type="math/tex">c<1</script>和所有足够大的<script type="math/tex">n</script>有<script type="math/tex">af(n/b)\leq cf(n)</script>，则<script type="math/tex">T(n)=\theta(f(n))</script>。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;对于归并排序算法，我们有<script type="math/tex">a=2,b=2,f(n)=\theta(n)</script>，则<script type="math/tex">n^{log_ba}=n^{log_22}=n</script>，两者大小相当，应用情况2。于是我们求得<script type="math/tex">T(n)=\theta(nlgn)</script>。</p>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础-动态规划</title>
    <url>/2021/01/26/suan-fa-ji-chu-dong-tai-gui-hua/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;同<a href="/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/">贪心算法</a>一样，动态规划所要解决的问题通常也是最优解问题。在策略上，动态规划与<a href="/2021/01/25/suan-fa-ji-chu-fen-zhi-fa/">分治法</a>相似，都是把复杂问题分解为数个子问题。不同的地方在于，分治法分解出的子问题均是独立的，即均需要进行单独的演算。而动态规划解决的是公共子问题，并将其保存以供重复利用，因此避免了大量不必要的计算工作。</p>
<a id="more"></a>
<p>&emsp;&emsp;一个动态规划算法的步骤大致有如下四步：</p>
<blockquote>
<ol>
<li>刻画一个最优解的结构特征。</li>
<li>递归地定义最优解的值。</li>
<li>计算最优解的值，通常采用自底向上的方法。</li>
<li>利用计算出的信息构造一个最优解。</li>
</ol>
</blockquote>
<h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>&emsp;&emsp;对于给定的一段长为n英寸的钢条和一个价格表<script type="math/tex">p_i</script>（样例如下）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度<script type="math/tex">i</script></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>价格<script type="math/tex">P_i</script></td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>24</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;假设切割所需的成本为0，如何切割钢条可以使收益<script type="math/tex">r_n</script>最大化？</p>
<p>&emsp;&emsp;应用动态规划的思想，我们将原问题分解为一系列子问题。</p>
<h4 id="最优解的结构特征"><a href="#最优解的结构特征" class="headerlink" title="最优解的结构特征"></a>最优解的结构特征</h4><p>&emsp;&emsp;对于一个钢条，我们总可以选择一个切割方案将钢条切成<script type="math/tex">k</script>段（<script type="math/tex">k=1</script>时表示不切割）如此一个最优解就应当是这种形式：</p>
<script type="math/tex; mode=display">n=i_1+i_2+\cdots+i_n</script><p>&emsp;&emsp;从而获取最大收益<script type="math/tex">r_n</script></p>
<script type="math/tex; mode=display">r_n=p_{i_1}+p_{i_2}+\cdots+p_{i_n}</script><p>&emsp;&emsp;考虑<script type="math/tex">n=1</script>的情况，只能选择不切割的方案，此时获取收益为1。考虑<script type="math/tex">n=2</script>的情况，可以选择不切割或切割为两个长度为1的钢条，取收益较大者即可。而对于更普遍的情况，实际上我们总能用如下表达式表示最大收益。</p>
<script type="math/tex; mode=display">r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},\cdots,r_{n-1}+r_1)\tag{1}</script><blockquote>
<p>这里应该可以省去一半的计算量</p>
</blockquote>
<p>&emsp;&emsp;可以看出我们为了获取更普遍的情况，实际上是用子问题的最优解组合出最优解。因此我们说钢条切割问题具有<strong>最优子结构性质</strong>。</p>
<div class="note warning">
            <h5 id="注意与分治法的区别！"><a href="#注意与分治法的区别！" class="headerlink" title="注意与分治法的区别！"></a>注意与分治法的区别！</h5><p>&emsp;&emsp;分治法不要求问题具有最优子结构性质，例如归并排序时我们只需要能够利用两子序列归并即可。但对于每一个子问题均是独立存在的，是需要单独计算的。而对于不具有最优子结构性质的问题，我们几乎就能断言其不适用动态规划了。</p>
          </div>
<h4 id="递归地定义最优解的值"><a href="#递归地定义最优解的值" class="headerlink" title="递归地定义最优解的值"></a>递归地定义最优解的值</h4><p>&emsp;&emsp;简化<script type="math/tex">(1)</script>可以得到<script type="math/tex">r_n=\max\limits_{1\leq i\leq n}(p_i+r_{n-i})</script>。因此我们可以得到如下伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为数组，即价格表；n为待处理钢条长度</span><br><span class="line">    if(n &#x3D;&#x3D; 0)                                 &#x2F;&#x2F; 长度为0没有收益</span><br><span class="line">        return 0</span><br><span class="line">    q &#x3D; -inf                                   &#x2F;&#x2F; 初始化</span><br><span class="line">    for i &#x3D; 1 to n</span><br><span class="line">        q &#x3D; max(q, p[i] + CUT-ROD(p,n - i))</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;至此，这个算法确实可以计算出最优解。但由于其递归实现，其时间复杂度相当巨大。分析n=3的情况，可以得到如下递归树。</p>
<pre class="mermaid">graph TB
    n11((3))
    n21((2))
    n22((1))
    n23((0))
    n31((1))
    n32((0))
    n33((0))
    n41((0))
    n11---n21
    n11---n22
    n11---n23
    n21---n31
    n21---n32
    n22---n33
    n31---n41</pre>

<p>&emsp;&emsp;由递归树可知，对n个输入，对应结点数目为<script type="math/tex">2^n</script>个。其中有很多部分是重复的子问题，如果我们能够将其保存并加以利用，那么就可以降低算法的复杂度了。</p>
<blockquote>
<script type="math/tex; mode=display">
T(n) =
\begin{cases}
1&\text{若n=0}\\
\sum\limits_{j=0}^{n-1}T(j)&{其他}
\end{cases}</script><p>可以证明<script type="math/tex">T(n)=2^n</script>，为一指数函数。实际上到这一步，对于分治法来说已经足够了，但对于动态规划还远远不够。</p>
</blockquote>
<h4 id="计算最优解的值"><a href="#计算最优解的值" class="headerlink" title="计算最优解的值"></a>计算最优解的值</h4><p>&emsp;&emsp;由于递归版本的算法运行时间太长，实用性很低，因此有必要进行改进。改进的方法一般有两种，一是<strong>带备忘的自顶向下法</strong>，二是<strong>自底向上法</strong>。</p>
<h5 id="带备忘的自顶向下法"><a href="#带备忘的自顶向下法" class="headerlink" title="带备忘的自顶向下法"></a>带备忘的自顶向下法</h5><p>&emsp;&emsp;如字面意思，该版本的改进在于在递归过程中加入了对子问题最优解值的保存。在需要子问题的解的时候，程序首先检查是否保存了该解，从而省去了计算的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 带备忘的自顶向下法的伪代码描述</span><br><span class="line">MEMOIZED-CUT-ROD(p, n)</span><br><span class="line">&#x2F;&#x2F; p为价格表，n为待处理钢条长度</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    for i &#x3D; 0 to n</span><br><span class="line">        r[i] &#x3D; -inf                                              &#x2F;&#x2F; 初始化备忘</span><br><span class="line">    return MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line"></span><br><span class="line">MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line">    if r[n] &gt;&#x3D; 0</span><br><span class="line">        return r[n]                                              &#x2F;&#x2F; 存在备忘直接取出</span><br><span class="line">    if n &#x3D;&#x3D; 0</span><br><span class="line">        q &#x3D; 0</span><br><span class="line">    else q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 0 to n</span><br><span class="line">            q &#x3D; max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i ,r))</span><br><span class="line">    r[n] &#x3D; q                                                     &#x2F;&#x2F; 保存备忘</span><br><span class="line">    return q</span><br></pre></td></tr></table></figure>
<h5 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] be a new array</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            q &#x3D; max(q, p[i] + r[j-i])</span><br><span class="line">        r[j]&#x3D;q</span><br><span class="line">    return r[n]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与自顶向下法比较，可以发现自底向上法最重要的地方三添加了第4行，以及将递归调用改为直接从r中取出。由于用取值代替了递归调用，算法自然不能像递归算法一样一层层继续下去，因此有必要添加自底向上的迭代方法。</p>
<p>&emsp;&emsp;容易得到该改进版本运行时间为<script type="math/tex">\theta(n^2)</script>，实际上MEMOIZED-CUT-ROD运行时间也是上式。</p>
<h4 id="利用计算出的信息构造一个最优解"><a href="#利用计算出的信息构造一个最优解" class="headerlink" title="利用计算出的信息构造一个最优解"></a>利用计算出的信息构造一个最优解</h4><p>&emsp;&emsp;到这一步我们已经计算得到了最大收益的值，但实际上对于钢条的切割方案并未提供最优解。这一步就是要保存每一段切割长度<script type="math/tex">s_j</script>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXTENDED-BOTTOM-UP-CUT-ROD(p, n)</span><br><span class="line">    let r[0..n] and s[0..n] be new arrays                &#x2F;&#x2F; r是备忘，s是最优解</span><br><span class="line">    r[0] &#x3D; 0</span><br><span class="line">    for j &#x3D; 1 to n</span><br><span class="line">        q &#x3D; -inf</span><br><span class="line">        for i &#x3D; 1 to j</span><br><span class="line">            if q &lt; p[i] + r[j-i]</span><br><span class="line">                q &#x3D; p[i] + r[j-i]</span><br><span class="line">                s[j] &#x3D; i</span><br><span class="line">        r[j] &#x3D; q</span><br><span class="line">    return r and s</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;要应用动态规划解决问题，问题需要具备以下两个性质：<strong>最优子结构</strong>和<strong>子问题重叠</strong>。</p>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础-贪心算法</title>
    <url>/2021/01/22/suan-fa-ji-chu-tan-xin-suan-fa/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>&emsp;&emsp;在现实世界中我们会遇到一种问题：对于给定的n个输入，其解由这n个输入的某子集组成，该子集满足某种给定<strong>约束条件</strong>。对于某一问题来说，满足约束条件的<strong>可行解</strong>可能不止一个。为了衡量解的优劣，事先给出了判断的标准，即<strong>目标函数</strong>。使目标函数取得极值的解，即为<strong>最优解</strong>。</p>
<p>&emsp;&emsp;为了解决这类最优解问题，有线性规划、整数规划、非线性规划等等一系列算法。但对于其中的一些问题，可以用一种更直接的方法进行求解——贪心算法。</p>
<a id="more"></a>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>&emsp;&emsp;贪心算法是一种改进了的分级处理方法。首先根据问题选取一种度量方法；然后按照度量标准对n个输入排序，并按序一次输入一个量。如果该输入和当前已经构成的部分最优解加一起不能构成可行解，则不把该输入加入到解中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 贪心算法的伪代码描述</span><br><span class="line">procedure GREEDY(A, n)                           &#x2F;&#x2F; A(1 : n) 包含n个输入</span><br><span class="line">    solution &lt;- NULL                             &#x2F;&#x2F; 解向量初始化为空</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        x &lt;- SELECT(A)                           &#x2F;&#x2F; 按照某种度量方法选择一个输入</span><br><span class="line">        if FEASIBLE(solution, x)                 &#x2F;&#x2F; 判断包含x的集是否为可行解</span><br><span class="line">            then solution &lt;- UNION(solution, x)  &#x2F;&#x2F; 如可行，将x作为可行解的一部分</span><br><span class="line">        endif</span><br><span class="line">    repeat</span><br><span class="line">    return(solution)</span><br><span class="line">end GREEDY</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;要注意的是，许多量度标准取得的解并不是最优解，而是次优解。把目标函数作为量度标准的解也不一定是问题的最优解。实际上，选出最优量度标准不是是一件容易的事。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>&emsp;&emsp;设想这样一个场景：有一个最大承重<script type="math/tex">M</script>的背包，对于每种物品<script type="math/tex">i</script>的重量为<script type="math/tex">W_i</script>。假定当物品<script type="math/tex">i</script>的一部分<script type="math/tex">x_i</script>装入背包中可以获得<script type="math/tex">p_i x_i</script>的效益（<script type="math/tex">0 \leq x_i \leq 1, p_i > 0</script>）。求采用何种策略才能使得效益最大化？</p>
<p>&emsp;&emsp;以上问题可以用数学语言描述如下：</p>
<ul>
<li>目标函数（取极大值）<script type="math/tex; mode=display">
\sum\limits_{1 \leq i \leq n} p_i x_i</script></li>
<li>约束条件<script type="math/tex; mode=display">
\sum\limits_{1 \leq i \leq n} w_i x_i \leq M</script><script type="math/tex; mode=display">
0 \leq x_i \leq 1 , p_i > 0, 1 \leq i \leq n</script></li>
</ul>
<p>&emsp;&emsp;自然我们会希望背包装的东西在占用重量少的情况下又尽可能地能产生更大的效益。因此，我们可以把<script type="math/tex">p_i / w_i</script>作为量度标准。经过测试，采用这种量度标准的贪心算法可以获得最优解。将物体按<script type="math/tex">p_i / w_i</script>的递减次序排序，则过程 GREEDY-KNAPSACK 就得出一个最优解。如果不考虑排序的时间，则算法的需要的时间为O(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procedure GREEDY-KNAPSACK(P, W, M, X, n)</span><br><span class="line">    &#x2F;&#x2F; P(1:n)和W(1:n)分别含有按P(i)&#x2F;W(i) &gt;&#x3D; P(i+1)&#x2F;W(i+1)排序的n件物品的效益值和</span><br><span class="line">    &#x2F;&#x2F; 重量。M是背包的容量大小，X(1:n)是解向量。</span><br><span class="line">    real P(1:n), W(1:n), X(1:n), M, cu;</span><br><span class="line">    integer i, n;</span><br><span class="line">    X &lt;- 0     &#x2F;&#x2F; 将解向量初始化为0</span><br><span class="line">    cu &lt;- M    &#x2F;&#x2F; cu是背包剩余容量</span><br><span class="line">    for i &lt;- 1 to n do</span><br><span class="line">        if W(i) &gt; cu then exit endif</span><br><span class="line">        X(i) &lt;- 1</span><br><span class="line">        cu &lt;- cu - W(i)</span><br><span class="line">    repeat</span><br><span class="line">    if i &lt;&#x3D; n then X(i) &lt;- cu&#x2F;W(i)</span><br><span class="line">    endif</span><br><span class="line">end GREEDY-KNAPSACK</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由此可见，贪心算法的核心在于量度标准的选取。</p>
<h3 id="如何证明？"><a href="#如何证明？" class="headerlink" title="如何证明？"></a>如何证明？</h3><p>&emsp;&emsp;以上我们提到的关于背包问题的一种策略的解是最优解。我们该如何证明这一点呢？</p>
<p>&emsp;&emsp;有一个基本的想法是，把贪心算法的解与任一已知最优解作比较。如果这两个解不同，则按照解向量依次对<script type="math/tex">x_i</script>做替换。如果贪心解是最优解，那么在分量置换后的解也应当是个最优解，在背包问题中即总效应不变。重复执行这种替换，直到二者完全相同，就证明了贪心算法的解是最优解。</p>
<blockquote>
<p>设X=(1:n)是上述策略产生的贪心解。若所有的<script type="math/tex">x_i</script>都为1，则显然该解为最优解。</p>
<p>考虑不全为1的情况，由算法可知，存在一个j为<script type="math/tex">x_j \neq 1</script>的最小下标。若X不是一个最优解，则必然存在一个最优解Y使<script type="math/tex">\sum\limits_{1\leq i\leq n}p_iy_i>\sum\limits_{1\leq i\leq n}p_ix_i</script>。</p>
<p>设k是<script type="math/tex">y_k \neq x_k</script>的最小下标。从<script type="math/tex">k < j, k = j, k > j</script>三个方面展开讨论。</p>
<p>1）若<script type="math/tex">k < j</script>，则<script type="math/tex">x_k = 1</script>。由于<script type="math/tex">y_k < x_k</script>，从而<script type="math/tex">y_k < x_k</script>。</p>
<p>2）若<script type="math/tex">k = j</script>，由于<script type="math/tex">\sum w_j x_i = M</script>，且对<script type="math/tex">1 \leq i < j</script>，有<script type="math/tex">x_i = y_i = 1</script>，而对<script type="math/tex">j < i \leq n</script>，有<script type="math/tex">x_i = 0</script>。若<script type="math/tex">y_k > x_k</script>，则<script type="math/tex">\sum w_j y_i > M</script>，与题设矛盾。故<script type="math/tex">y_k < x_k</script>。</p>
<p>3）若<script type="math/tex">k > j</script>，显然这是不可能的。</p>
<p>由此我们得到了<script type="math/tex">y_k < x_k</script>的结论。</p>
<p>现在假设我们把<script type="math/tex">y_k</script>增加到<script type="math/tex">x_k</script>，则需要从<script type="math/tex">(y_{k+1}, y_{k+2},...,y_n)</script>中减去同样多的量。使总量仍然为M。这就导致了一个新解Z。且有<script type="math/tex">\sum\limits_{k<i\leq n} w_i(y_i - z_i) = w_k(z_k -y_k)</script>。</p>
<script type="math/tex; mode=display">
\begin{align}
\sum\limits_{1\leq i \leq n}p_iz_i &= \sum\limits_{1\leq i\leq n}p_iy_i+(z_k-y_k)w_kp_k/w_k - \sum\limits_{k<i\leq n}(y_i-z_i)w_ip_i/w_i\\
&\geq \sum\limits_{1\leq i\leq n}p_iy_i+[(z_k-y_k)w_k-\sum\limits_{k<i\leq n}(y_i-z_i)w_i]p_i/w_k\\
&= \sum\limits_{1\leq i\leq n}p_iy_i
\end{align}</script><p>若<script type="math/tex">\sum p_iz_i>\sum p_iy_i</script>，则Y不可能是最优解。若取等，<script type="math/tex">Z=X</script>，则<script type="math/tex">X</script>为最优解；若<script type="math/tex">Z\neq X</script>，则需重复以上讨论，或者证明Y不是最优解，或者把Y转换成X，从而证明X也是最优解。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
</search>
